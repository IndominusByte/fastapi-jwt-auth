{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FastAPI JWT Auth Documentation : https://indominusbyte.github.io/fastapi-jwt-auth Source Code : https://github.com/IndominusByte/fastapi-jwt-auth Features \u00b6 FastAPI extension that provides JWT Auth support (secure, easy to use and lightweight), if you were familiar with flask-jwt-extended this extension suitable for you, cause this extension inspired by flask-jwt-extended \ud83d\ude00 Access tokens and refresh tokens Freshness Tokens Revoking Tokens Support for WebSocket authorization Support for adding custom claims to JSON Web Tokens Storing tokens in cookies and CSRF protection Installation \u00b6 The easiest way to start working with this extension with pip pip install fastapi-jwt-auth If you want to use asymmetric (public/private) key signing algorithms, include the asymmetric extra requirements. pip install 'fastapi-jwt-auth[asymmetric]' License \u00b6 This project is licensed under the terms of the MIT license.","title":"About"},{"location":"#features","text":"FastAPI extension that provides JWT Auth support (secure, easy to use and lightweight), if you were familiar with flask-jwt-extended this extension suitable for you, cause this extension inspired by flask-jwt-extended \ud83d\ude00 Access tokens and refresh tokens Freshness Tokens Revoking Tokens Support for WebSocket authorization Support for adding custom claims to JSON Web Tokens Storing tokens in cookies and CSRF protection","title":"Features"},{"location":"#installation","text":"The easiest way to start working with this extension with pip pip install fastapi-jwt-auth If you want to use asymmetric (public/private) key signing algorithms, include the asymmetric extra requirements. pip install 'fastapi-jwt-auth[asymmetric]'","title":"Installation"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"api-doc/","text":"In here you will find the API for everything exposed in this extension. Configuring FastAPI JWT Auth \u00b6 load_config (callback) This decorator sets the callback function to overwrite state on AuthJWT class so when you initialize an instance in dependency injection default value will be overwritten. Hint : The callback must be a function that returns a list of tuple or pydantic object. token_in_denylist_loader (callback) This decorator sets the callback function that will be called when a protected endpoint is accessed and will check if the JWT has been revoked. By default, this callback is not used. Hint : The callback must be a function that takes one argument, which is the decoded JWT (python dictionary), and returns True if the token has been revoked, or False otherwise. Protected Endpoint \u00b6 jwt_required (auth_from=\"request\", token=None, websocket=None, csrf_token=None) If you call this function, it will ensure that the requester has a valid access token before executing the code below your router. This does not check the freshness of the access token. Parameters: auth_from : For identity get token from HTTP or WebSocket token : The encoded JWT, it's required if the protected endpoint use WebSocket to authorization and get token from Query Url or Path websocket : An instance of WebSocket, it's required if protected endpoint use a cookie to authorization csrf_token : The CSRF double submit token. Since WebSocket cannot add specifying additional headers its must be passing csrf_token manually and can achieve by Query Url or Path Returns: None jwt_optional (auth_from=\"request\", token=None, websocket=None, csrf_token=None) If an access token present in the request, this will call the endpoint with get_jwt_identity() having the identity of the access token. If no access token is present in the request, this endpoint will still be called, but get_jwt_identity() will return None instead. If there is an invalid access token in the request (expired, tampered with, etc), this will still call the appropriate error handler. Parameters: auth_from : For identity get token from HTTP or WebSocket token : The encoded JWT, it's required if the protected endpoint use WebSocket to authorization and get token from Query Url or Path websocket : An instance of WebSocket, it's required if protected endpoint use a cookie to authorization csrf_token : The CSRF double submit token. Since WebSocket cannot add specifying additional headers its must be passing csrf_token manually and can achieve by Query Url or Path Returns: None jwt_refresh_token_required (auth_from=\"request\", token=None, websocket=None, csrf_token=None) If you call this function, it will ensure that the requester has a valid refresh token before executing the code below your router. Parameters: auth_from : For identity get token from HTTP or WebSocket token : The encoded JWT, it's required if the protected endpoint use WebSocket to authorization and get token from Query Url or Path websocket : An instance of WebSocket, it's required if protected endpoint use a cookie to authorization csrf_token : The CSRF double submit token. Since WebSocket cannot add specifying additional headers its must be passing csrf_token manually and can achieve by Query Url or Path Returns: None fresh_jwt_required (auth_from=\"request\", token=None, websocket=None, csrf_token=None) If you call this function, it will ensure that the requester has a valid and fresh access token before executing the code below your router. Parameters: auth_from : For identity get token from HTTP or WebSocket token : The encoded JWT, it's required if the protected endpoint use WebSocket to authorization and get token from Query Url or Path websocket : An instance of WebSocket, it's required if protected endpoint use a cookie to authorization csrf_token : The CSRF double submit token. Since WebSocket cannot add specifying additional headers its must be passing csrf_token manually and can achieve by Query Url or Path Returns: None Utilities \u00b6 create_access_token (subject, fresh=False, algorithm=None, headers=None, expires_time=None, audience=None, user_claims={}) Create a new access token. Parameters: subject : Identifier for who this token is for example id or username from database fresh : Identify token is fresh or non-fresh algorithm : Algorithm allowed to encode the token headers : Valid dict for specifying additional headers in JWT header section expires_time : Set the duration of the JWT audience : Expected audience in the JWT user_claims : Custom claims to include in this token. This data must be dictionary Returns: An encoded access token create_refresh_token (subject, algorithm=None, headers=None, expires_time=None, audience=None, user_claims={}) Creates a new refresh token. Parameters: subject : Identifier for who this token is for example id or username from database algorithm : Algorithm allowed to encode the token headers : Valid dict for specifying additional headers in JWT header section expires_time : Set the duration of the JWT audience : Expected audience in the JWT user_claims : Custom claims to include in this token. This data must be dictionary Returns: An encoded refresh token set_access_cookies (encoded_access_token, response=None, max_age=None) Configures the response to set access token in a cookie. This will also set the CSRF double submit values in a separate cookie. Parameters: encoded_access_token : The encoded access token to set in the cookies response : The FastAPI response object to set the access cookies in max_age : The max age of the cookie value should be integer the number of seconds Returns: None set_refresh_cookies (encoded_refresh_token, response=None, max_age=None) Configures the response to set refresh token in a cookie. This will also set the CSRF double submit values in a separate cookie. Parameters: encoded_refresh_token : The encoded refresh token to set in the cookies response : The FastAPI response object to set the refresh cookies in max_age : The max age of the cookie value should be integer the number of seconds Returns: None unset_jwt_cookies (response=None) Unset (delete) all jwt stored in a cookies. Parameters: response : The FastAPI response object to delete the JWT cookies in Returns: None unset_access_cookies (response=None) Remove access token and access CSRF double submit from the response cookies. Parameters: response : The FastAPI response object to delete the access cookies in Returns: None unset_refresh_cookies (response=None) Remove refresh token and refresh CSRF double submit from the response cookies. Parameters: response : The FastAPI response object to delete the refresh cookies in Returns: None get_raw_jwt (encoded_token=None) This will return the python dictionary which has all of the claims of the JWT that is accessing the endpoint. If no JWT is currently present, return None instead. Parameters: encoded_token : The encoded JWT from parameter Returns: Claims of JWT get_jti (encoded_token) Returns the JTI (unique identifier) of an encoded JWT Parameters: encoded_token : The encoded JWT from parameter Returns: String of JTI get_jwt_subject () This will return the subject of the JWT that is accessing the endpoint. If no JWT is present, None is returned instead. get_unverified_jwt_headers (encoded_token=None) Returns the Headers of an encoded JWT without verifying the actual signature of JWT. Parameters: encoded_token : The encoded JWT to get the Header from protected endpoint or from parameter Returns: JWT header parameters as a dictionary","title":"API Documentation"},{"location":"api-doc/#configuring-fastapi-jwt-auth","text":"load_config (callback) This decorator sets the callback function to overwrite state on AuthJWT class so when you initialize an instance in dependency injection default value will be overwritten. Hint : The callback must be a function that returns a list of tuple or pydantic object. token_in_denylist_loader (callback) This decorator sets the callback function that will be called when a protected endpoint is accessed and will check if the JWT has been revoked. By default, this callback is not used. Hint : The callback must be a function that takes one argument, which is the decoded JWT (python dictionary), and returns True if the token has been revoked, or False otherwise.","title":"Configuring FastAPI JWT Auth"},{"location":"api-doc/#protected-endpoint","text":"jwt_required (auth_from=\"request\", token=None, websocket=None, csrf_token=None) If you call this function, it will ensure that the requester has a valid access token before executing the code below your router. This does not check the freshness of the access token. Parameters: auth_from : For identity get token from HTTP or WebSocket token : The encoded JWT, it's required if the protected endpoint use WebSocket to authorization and get token from Query Url or Path websocket : An instance of WebSocket, it's required if protected endpoint use a cookie to authorization csrf_token : The CSRF double submit token. Since WebSocket cannot add specifying additional headers its must be passing csrf_token manually and can achieve by Query Url or Path Returns: None jwt_optional (auth_from=\"request\", token=None, websocket=None, csrf_token=None) If an access token present in the request, this will call the endpoint with get_jwt_identity() having the identity of the access token. If no access token is present in the request, this endpoint will still be called, but get_jwt_identity() will return None instead. If there is an invalid access token in the request (expired, tampered with, etc), this will still call the appropriate error handler. Parameters: auth_from : For identity get token from HTTP or WebSocket token : The encoded JWT, it's required if the protected endpoint use WebSocket to authorization and get token from Query Url or Path websocket : An instance of WebSocket, it's required if protected endpoint use a cookie to authorization csrf_token : The CSRF double submit token. Since WebSocket cannot add specifying additional headers its must be passing csrf_token manually and can achieve by Query Url or Path Returns: None jwt_refresh_token_required (auth_from=\"request\", token=None, websocket=None, csrf_token=None) If you call this function, it will ensure that the requester has a valid refresh token before executing the code below your router. Parameters: auth_from : For identity get token from HTTP or WebSocket token : The encoded JWT, it's required if the protected endpoint use WebSocket to authorization and get token from Query Url or Path websocket : An instance of WebSocket, it's required if protected endpoint use a cookie to authorization csrf_token : The CSRF double submit token. Since WebSocket cannot add specifying additional headers its must be passing csrf_token manually and can achieve by Query Url or Path Returns: None fresh_jwt_required (auth_from=\"request\", token=None, websocket=None, csrf_token=None) If you call this function, it will ensure that the requester has a valid and fresh access token before executing the code below your router. Parameters: auth_from : For identity get token from HTTP or WebSocket token : The encoded JWT, it's required if the protected endpoint use WebSocket to authorization and get token from Query Url or Path websocket : An instance of WebSocket, it's required if protected endpoint use a cookie to authorization csrf_token : The CSRF double submit token. Since WebSocket cannot add specifying additional headers its must be passing csrf_token manually and can achieve by Query Url or Path Returns: None","title":"Protected Endpoint"},{"location":"api-doc/#utilities","text":"create_access_token (subject, fresh=False, algorithm=None, headers=None, expires_time=None, audience=None, user_claims={}) Create a new access token. Parameters: subject : Identifier for who this token is for example id or username from database fresh : Identify token is fresh or non-fresh algorithm : Algorithm allowed to encode the token headers : Valid dict for specifying additional headers in JWT header section expires_time : Set the duration of the JWT audience : Expected audience in the JWT user_claims : Custom claims to include in this token. This data must be dictionary Returns: An encoded access token create_refresh_token (subject, algorithm=None, headers=None, expires_time=None, audience=None, user_claims={}) Creates a new refresh token. Parameters: subject : Identifier for who this token is for example id or username from database algorithm : Algorithm allowed to encode the token headers : Valid dict for specifying additional headers in JWT header section expires_time : Set the duration of the JWT audience : Expected audience in the JWT user_claims : Custom claims to include in this token. This data must be dictionary Returns: An encoded refresh token set_access_cookies (encoded_access_token, response=None, max_age=None) Configures the response to set access token in a cookie. This will also set the CSRF double submit values in a separate cookie. Parameters: encoded_access_token : The encoded access token to set in the cookies response : The FastAPI response object to set the access cookies in max_age : The max age of the cookie value should be integer the number of seconds Returns: None set_refresh_cookies (encoded_refresh_token, response=None, max_age=None) Configures the response to set refresh token in a cookie. This will also set the CSRF double submit values in a separate cookie. Parameters: encoded_refresh_token : The encoded refresh token to set in the cookies response : The FastAPI response object to set the refresh cookies in max_age : The max age of the cookie value should be integer the number of seconds Returns: None unset_jwt_cookies (response=None) Unset (delete) all jwt stored in a cookies. Parameters: response : The FastAPI response object to delete the JWT cookies in Returns: None unset_access_cookies (response=None) Remove access token and access CSRF double submit from the response cookies. Parameters: response : The FastAPI response object to delete the access cookies in Returns: None unset_refresh_cookies (response=None) Remove refresh token and refresh CSRF double submit from the response cookies. Parameters: response : The FastAPI response object to delete the refresh cookies in Returns: None get_raw_jwt (encoded_token=None) This will return the python dictionary which has all of the claims of the JWT that is accessing the endpoint. If no JWT is currently present, return None instead. Parameters: encoded_token : The encoded JWT from parameter Returns: Claims of JWT get_jti (encoded_token) Returns the JTI (unique identifier) of an encoded JWT Parameters: encoded_token : The encoded JWT from parameter Returns: String of JTI get_jwt_subject () This will return the subject of the JWT that is accessing the endpoint. If no JWT is present, None is returned instead. get_unverified_jwt_headers (encoded_token=None) Returns the Headers of an encoded JWT without verifying the actual signature of JWT. Parameters: encoded_token : The encoded JWT to get the Header from protected endpoint or from parameter Returns: JWT header parameters as a dictionary","title":"Utilities"},{"location":"contributing/","text":"Sharing feedback \u00b6 This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments . If you want to contribute thankss a lot , you can open an issue on Github. Developing \u00b6 If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment. Virtual environment with venv \u00b6 You can create a virtual environment in a directory using Python's venv module: $ python3 -m venv env That will create a directory ./env/ with the Python binaries and then you will be able to install packages for that isolated environment. Activate the environment \u00b6 $ source ./env/bin/activate To check it worked, use: $ which pip some/directory/fastapi-jwt-auth/env/bin/pip If it shows the pip binary at env/bin/pip then it worked. \ud83c\udf89 Tip Every time you install a new package with pip under that environment, activate the environment again. This makes sure that if you use a terminal program installed by that package (like flit ), you use the one from your local environment and not any other that could be installed globally. Flit \u00b6 FastAPI JWT Auth uses Flit to build, package and publish the project. After activating the environment as described above, install flit : $ pip install flit Now re-activate the environment to make sure you are using the flit you just installed (and not a global one). And now use flit to install the development dependencies: $ flit install --deps develop --symlink It will install all the dependencies and your local FastAPI JWT Auth in your local environment. Using your local FastAPI JWT Auth If you create a Python file that imports and use FastAPI JWT Auth, and run it with the Python from your local environment, it will use your localFastAPI JWT Auth source code. And if you update that local FastAPI JWT Auth source code, as it is installed with --symlink , when you run that Python file again, it will use the fresh version of FastAPI JWT Auth you just edited. That way, you don't have to \"install\" your local version to be able to test every change. Docs \u00b6 The documentation uses MkDocs . All the documentation is in Markdown format in the directory ./docs . Many of the sections in the User Guide have blocks of code. In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./examples/ directory. And those Python files are included/injected in the documentation when generating the site. Docs for tests \u00b6 Most of the tests actually run against the example source files in the documentation. This helps making sure that: The documentation is up to date. The documentation examples can be run as is. Most of the features are covered by the documentation, ensured by test coverage. During local development, there is a script that builds the site and checks for any changes, live-reloading: $ bash scripts/docs-live.sh It will serve the documentation on http://0.0.0.0:5000 . That way, you can edit the documentation/source files and see the changes live. Tests \u00b6 There is a script that you can run locally to test all the code and generate coverage reports in HTML: $ bash scripts/tests.sh This command generates a directory ./htmlcov/ , if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.","title":"Development - Contributing"},{"location":"contributing/#sharing-feedback","text":"This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments . If you want to contribute thankss a lot , you can open an issue on Github.","title":"Sharing feedback"},{"location":"contributing/#developing","text":"If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment.","title":"Developing"},{"location":"contributing/#virtual-environment-with-venv","text":"You can create a virtual environment in a directory using Python's venv module: $ python3 -m venv env That will create a directory ./env/ with the Python binaries and then you will be able to install packages for that isolated environment.","title":"Virtual environment with venv"},{"location":"contributing/#activate-the-environment","text":"$ source ./env/bin/activate To check it worked, use: $ which pip some/directory/fastapi-jwt-auth/env/bin/pip If it shows the pip binary at env/bin/pip then it worked. \ud83c\udf89 Tip Every time you install a new package with pip under that environment, activate the environment again. This makes sure that if you use a terminal program installed by that package (like flit ), you use the one from your local environment and not any other that could be installed globally.","title":"Activate the environment"},{"location":"contributing/#flit","text":"FastAPI JWT Auth uses Flit to build, package and publish the project. After activating the environment as described above, install flit : $ pip install flit Now re-activate the environment to make sure you are using the flit you just installed (and not a global one). And now use flit to install the development dependencies: $ flit install --deps develop --symlink It will install all the dependencies and your local FastAPI JWT Auth in your local environment. Using your local FastAPI JWT Auth If you create a Python file that imports and use FastAPI JWT Auth, and run it with the Python from your local environment, it will use your localFastAPI JWT Auth source code. And if you update that local FastAPI JWT Auth source code, as it is installed with --symlink , when you run that Python file again, it will use the fresh version of FastAPI JWT Auth you just edited. That way, you don't have to \"install\" your local version to be able to test every change.","title":"Flit"},{"location":"contributing/#docs","text":"The documentation uses MkDocs . All the documentation is in Markdown format in the directory ./docs . Many of the sections in the User Guide have blocks of code. In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./examples/ directory. And those Python files are included/injected in the documentation when generating the site.","title":"Docs"},{"location":"contributing/#docs-for-tests","text":"Most of the tests actually run against the example source files in the documentation. This helps making sure that: The documentation is up to date. The documentation examples can be run as is. Most of the features are covered by the documentation, ensured by test coverage. During local development, there is a script that builds the site and checks for any changes, live-reloading: $ bash scripts/docs-live.sh It will serve the documentation on http://0.0.0.0:5000 . That way, you can edit the documentation/source files and see the changes live.","title":"Docs for tests"},{"location":"contributing/#tests","text":"There is a script that you can run locally to test all the code and generate coverage reports in HTML: $ bash scripts/tests.sh This command generates a directory ./htmlcov/ , if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.","title":"Tests"},{"location":"release-notes/","text":"0.5.0 \u00b6 Support for WebSocket authorization (Thanks to @SelfhostedPro for make issues) Function get_raw_jwt() can pass parameter encoded_token 0.4.0 \u00b6 Support set and unset cookies when returning a Response directly 0.3.0 \u00b6 (Deprecated) environment variable support Change name function load_end() -> load_config() Change name function get_jwt_identity() -> get_jwt_subject() Change name identity claims to standard claims sub (Thanks to @rassie for suggestion) Additional headers in claims Get additional headers claims from request or parsing token directly Leeway exp claim decode token Dynamic token expires time Change name blacklist -> denylist Denylist custom check refresh and access tokens Issuer claim Audience claim Jwt decode algorithms Dynamic algorithm create token Token multiple location Support RSA encryption (Thanks to @jet10000 for make issues) Custom header name and type Custom error message key and status code JWT in cookies (Thanks to @m4nuC for make issues) Add Additional claims Add Documentation PR #9 by @paulussimanjuntak 0.2.0 \u00b6 Call create_token and get_jti function must be from dependency injection Improve blacklist loader Can load env from pydantic Add docs on readme how to use without dependency injection and example on multiple files Fix raise jwt exception PR #1 by @ironslob 0.1.0 \u00b6 Initial release.","title":"Release Notes"},{"location":"release-notes/#050","text":"Support for WebSocket authorization (Thanks to @SelfhostedPro for make issues) Function get_raw_jwt() can pass parameter encoded_token","title":"0.5.0"},{"location":"release-notes/#040","text":"Support set and unset cookies when returning a Response directly","title":"0.4.0"},{"location":"release-notes/#030","text":"(Deprecated) environment variable support Change name function load_end() -> load_config() Change name function get_jwt_identity() -> get_jwt_subject() Change name identity claims to standard claims sub (Thanks to @rassie for suggestion) Additional headers in claims Get additional headers claims from request or parsing token directly Leeway exp claim decode token Dynamic token expires time Change name blacklist -> denylist Denylist custom check refresh and access tokens Issuer claim Audience claim Jwt decode algorithms Dynamic algorithm create token Token multiple location Support RSA encryption (Thanks to @jet10000 for make issues) Custom header name and type Custom error message key and status code JWT in cookies (Thanks to @m4nuC for make issues) Add Additional claims Add Documentation PR #9 by @paulussimanjuntak","title":"0.3.0"},{"location":"release-notes/#020","text":"Call create_token and get_jti function must be from dependency injection Improve blacklist loader Can load env from pydantic Add docs on readme how to use without dependency injection and example on multiple files Fix raise jwt exception PR #1 by @ironslob","title":"0.2.0"},{"location":"release-notes/#010","text":"Initial release.","title":"0.1.0"},{"location":"advanced-usage/additional-claims/","text":"You may want to store additional information in the access token or refresh token and you could later access in the protected views. This can be done easily by parsing additional information (dictionary python) to parameter user_claims in function create_access_token() or create_refresh_token() , and the data can be accessed later in a protected endpoint with the get_raw_jwt() function. Storing data in the tokens can be good for performance. If you store data in the tokens, you won't need to look it up from disk next time you need it in a protected endpoint. However, you should take care of what data you put in the tokens. Any data in the tokens can be trivially viewed by anyone who can read the tokens. Note : Do not store sensitive information in the tokens! from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # You can be passing custom claim to argument user_claims # in function create_access_token() or create refresh token() another_claims = { \"foo\" : [ \"fiz\" , \"baz\" ]} access_token = Authorize . create_access_token ( subject = user . username , user_claims = another_claims ) return { \"access_token\" : access_token } # In protected route, get the claims you added to the jwt with the # get_raw_jwt() method @app . get ( '/claims' ) def user ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () foo_claims = Authorize . get_raw_jwt ()[ 'foo' ] return { \"foo\" : foo_claims }","title":"Additional claims"},{"location":"advanced-usage/asymmetric/","text":"Usage of RSA RS* and EC EC* algorithms require a basic understanding of how public-key cryptography is used with regards to digital signatures. If you are familiar with that, you may want to use this. from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel # In the real case, you can put the # public key and private key in *.pem, *.key then you can read that file private_key = \"\"\" -----BEGIN RSA PRIVATE KEY----- MIICWwIBAAKBgGBoQhqHdMU65aSBQVC/u9a6HMfKA927aZOk7HA/kXuA5UU4Sl+U C9WjDhMQFk1PpqAjZdCqx9ajolTYnIfeaVHcLNpJQ6QXLnUyMnfwPmwYQ2rkuy5w I2NdO81CzJ/9S8MsPyMl2/CF9ZxM03eleE8RKFwXCxZ/IoiqN4jVNjSrAgMBAAEC gYAnNqEUq146zx8TT6PilWpxB9inByuVaCKkdGPbsG+bfa1D/4Z44/4AUsdpx5Ra s/hBkMRcIOsSChMAUe8xcK0DqA9Y7BIVfpma2fH/gYq6dP3dOfCxftZBF00HwIu7 5e7RWnBC8MkPnrkKdHq6ptAYlGgoSJTEQREqusDiuNG9yQJBAKQib2VhNAqgyvvi PdmFrCqq15z9MY16WCfttuqfAaSYKHnZe1WvBKbSNW9x4Cgjfhzl9mlozlW4rob/ ttPN6e0CQQCWXbVtqmVdB5Ol9wQN7DIRc8q5F8HKQqIJAMTmwaRwNDsGRxCWMwGO 8WAlnejzYTXmrrytv6kXX8U40enJW2X3AkAI42h+5/WmgbCcVVMeHXQGV3wXn0p4 q+BsQR4/tF6laCwA9TsNl827rvR/1X3bDpj8vaNLcAaEc9zXqK9g5uy9AkATeOkw 3Xso8/075eRBhU/qkKs1Ew2GiuB+9/mHxJXt7eWi53sPaGWQRFPmKy/qrLEVQZWv jn1wSHe65vw2lj57AkEAh04n1wrZnCha8s6crMhjggdTXI6G4FU3TGf8ssGboqs3 j5lemvyKod+u2JVKwarcKmd/gFYBOjsRm18LlZH74A== -----END RSA PRIVATE KEY----- \"\"\" public_key = \"\"\" -----BEGIN PUBLIC KEY----- MIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgGBoQhqHdMU65aSBQVC/u9a6HMfK A927aZOk7HA/kXuA5UU4Sl+UC9WjDhMQFk1PpqAjZdCqx9ajolTYnIfeaVHcLNpJ Q6QXLnUyMnfwPmwYQ2rkuy5wI2NdO81CzJ/9S8MsPyMl2/CF9ZxM03eleE8RKFwX CxZ/IoiqN4jVNjSrAgMBAAE= -----END PUBLIC KEY----- \"\"\" app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_algorithm : str = \"RS512\" authjwt_public_key : str = public_key authjwt_private_key : str = private_key @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user }","title":"Asymmetric Algorithm"},{"location":"advanced-usage/bigger-app/","text":"Because fastapi-jwt-auth configure your setting via class state that applies across all instances of the class. You need to make sure to call load_config (callback) above from your endpoint. Thanks to FastAPI when you make endpoint from APIRouter it will actually work as if everything was the same single app. So you only need to define load_config (callback) where Fastapi instance created or you can import it where you included all the router. An example file structure \u00b6 Let's say you have a file structure like this: . \u251c\u2500\u2500 multiple_files \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 app.py \u2502 \u2514\u2500\u2500 routers \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 items.py \u2502 \u2514\u2500\u2500 users.py Here an example of app.py from fastapi import FastAPI , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from routers import users , items from pydantic import BaseModel app = FastAPI () class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) app . include_router ( users . router , tags = [ 'users' ]) app . include_router ( items . router , tags = [ 'items' ]) Here an example of users.py from fastapi import APIRouter , Depends , HTTPException from fastapi_jwt_auth import AuthJWT from pydantic import BaseModel class User ( BaseModel ): username : str password : str router = APIRouter () @router . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } Here an example of items.py from fastapi import APIRouter , Depends from fastapi_jwt_auth import AuthJWT router = APIRouter () @router . get ( '/items' ) def items ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () items = [ \"item1\" , \"item2\" , \"item3\" ] return { \"items\" : items }","title":"Bigger Applications"},{"location":"advanced-usage/bigger-app/#an-example-file-structure","text":"Let's say you have a file structure like this: . \u251c\u2500\u2500 multiple_files \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 app.py \u2502 \u2514\u2500\u2500 routers \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 items.py \u2502 \u2514\u2500\u2500 users.py Here an example of app.py from fastapi import FastAPI , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from routers import users , items from pydantic import BaseModel app = FastAPI () class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) app . include_router ( users . router , tags = [ 'users' ]) app . include_router ( items . router , tags = [ 'items' ]) Here an example of users.py from fastapi import APIRouter , Depends , HTTPException from fastapi_jwt_auth import AuthJWT from pydantic import BaseModel class User ( BaseModel ): username : str password : str router = APIRouter () @router . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } Here an example of items.py from fastapi import APIRouter , Depends from fastapi_jwt_auth import AuthJWT router = APIRouter () @router . get ( '/items' ) def items ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () items = [ \"item1\" , \"item2\" , \"item3\" ] return { \"items\" : items }","title":"An example file structure"},{"location":"advanced-usage/dynamic-algorithm/","text":"You can specify which algorithm you would like to use to sign the JWT by using the algorithm parameter in create_access_token() or create_refresh_token() . Also you need to specify which algorithms you would like to permit when validating in protected endpoint by settings authjwt_decode_algorithms which take a sequence . If the JWT doesn't have algorithm in authjwt_decode_algorithms the token will be rejected. from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" # Configure algorithms which is permit authjwt_decode_algorithms : set = { \"HS384\" , \"HS512\" } @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # You can define different algorithm when create a token access_token = Authorize . create_access_token ( subject = user . username , algorithm = \"HS384\" ) refresh_token = Authorize . create_refresh_token ( subject = user . username , algorithm = \"HS512\" ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } # In protected route, automatically check incoming JWT # have algorithm in your `authjwt_decode_algorithms` or not @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } # In protected route, automatically check incoming JWT # have algorithm in your `authjwt_decode_algorithms` or not @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user }","title":"Dynamic Token Algorithm"},{"location":"advanced-usage/dynamic-expires/","text":"You can also change the expires time for a token via parameter expires_time in the create_access_token() or create_refresh_token() function. This takes a datetime.timedelta , integer , or even boolean and overrides the authjwt_access_token_expires and authjwt_refresh_token_expires settings. This can be useful if you have different use cases for different tokens. @app . post ( '/create-dynamic-token' ) def create_dynamic_token ( Authorize : AuthJWT = Depends ()): expires = datetime . timedelta ( days = 1 ) token = Authorize . create_access_token ( subject = \"test\" , expires_time = expires ) return { \"token\" : token } You can even disable expiration by setting expires_time to False : @app . post ( '/create-token-disable' ) def create_dynamic_token ( Authorize : AuthJWT = Depends ()): token = Authorize . create_access_token ( subject = \"test\" , expires_time = False ) return { \"token\" : token }","title":"Dynamic Token Expires"},{"location":"advanced-usage/generate-docs/","text":"It feels incomplete if there is no documentation because fastapi-jwt-auth that uses starlette request and response directly to get headers or cookies, you must manually generate the documentation. Thanks to FastAPI you can generate doc easily via Extending OpenAPI . Here is an example to generate the doc: from fastapi import FastAPI , Request , Depends , HTTPException from fastapi.responses import JSONResponse from fastapi.openapi.utils import get_openapi from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } @app . get ( '/protected' , operation_id = \"authorize\" ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user } def custom_openapi (): if app . openapi_schema : return app . openapi_schema openapi_schema = get_openapi ( title = \"Custom title\" , version = \"2.5.0\" , description = \"This is a very custom OpenAPI schema\" , routes = app . routes , ) # Custom documentation fastapi-jwt-auth headers = { \"name\" : \"Authorization\" , \"in\" : \"header\" , \"required\" : True , \"schema\" : { \"title\" : \"Authorization\" , \"type\" : \"string\" }, } # Get routes from index 4 because before that fastapi define router for /openapi.json, /redoc, /docs, etc # Get all router where operation_id is authorize router_authorize = [ route for route in app . routes [ 4 :] if route . operation_id == \"authorize\" ] for route in router_authorize : method = list ( route . methods )[ 0 ] . lower () try : # If the router has another parameter openapi_schema [ \"paths\" ][ route . path ][ method ][ 'parameters' ] . append ( headers ) except Exception : # If the router doesn't have a parameter openapi_schema [ \"paths\" ][ route . path ][ method ] . update ({ \"parameters\" :[ headers ]}) app . openapi_schema = openapi_schema return app . openapi_schema app . openapi = custom_openapi","title":"Generate Documentation"},{"location":"advanced-usage/websocket/","text":"The WebSocket protocol doesn\u2019t handle authorization or authentication. Practically, this means that a WebSocket opened from a page behind auth doesn\u2019t \"automatically\" receive any sort of auth. You need to take steps to also secure the WebSocket connection. Since you cannot customize WebSocket headers from JavaScript, you\u2019re limited to the \"implicit\" auth (i.e. Basic or cookies) that\u2019s sent from the browser. The more common approach to generates a token from your normal HTTP server and then have the client send the token (either as a query string in the WebSocket path or as the first WebSocket message). The WebSocket server then validates that the token is valid. Note : Change all IP address to your localhost Here is an example of how you authorize from query URL: from fastapi import FastAPI , WebSocket , Depends , Request , HTTPException , Query from fastapi.responses import HTMLResponse , JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) html = \"\"\" <!DOCTYPE html> <html> <head> <title>Authorize</title> </head> <body> <h1>WebSocket Authorize</h1> <p>Token:</p> <textarea id=\"token\" rows=\"4\" cols=\"50\"></textarea><br><br> <button onclick=\"websocketfun()\">Send</button> <ul id='messages'> </ul> <script> const websocketfun = () => { let token = document.getElementById(\"token\").value let ws = new WebSocket(`ws://192.168.18.202:8000/ws?token=$ {token} `) ws.onmessage = (event) => { let messages = document.getElementById('messages') let message = document.createElement('li') let content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) } } </script> </body> </html> \"\"\" @app . get ( \"/\" ) async def get (): return HTMLResponse ( html ) @app . websocket ( '/ws' ) async def websocket ( websocket : WebSocket , token : str = Query ( ... ), Authorize : AuthJWT = Depends ()): await websocket . accept () try : Authorize . jwt_required ( \"websocket\" , token = token ) # Authorize.jwt_optional(\"websocket\",token=token) # Authorize.jwt_refresh_token_required(\"websocket\",token=token) # Authorize.fresh_jwt_required(\"websocket\",token=token) await websocket . send_text ( \"Successfully Login!\" ) decoded_token = Authorize . get_raw_jwt ( token ) await websocket . send_text ( f \"Here your decoded token: { decoded_token } \" ) except AuthJWTException as err : await websocket . send_text ( err . message ) await websocket . close () @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username , fresh = True ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } You will see a simple page like this: You can copy the token from endpoint /login and then send them: And your WebSocket route will respond back if the token is valid or not: Here is an example of how you authorize from cookie: from fastapi import FastAPI , WebSocket , Depends , Query from fastapi.responses import HTMLResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" authjwt_token_location : set = { \"cookies\" } @AuthJWT . load_config def get_config (): return Settings () html = \"\"\" <!DOCTYPE html> <html> <head> <title>Authorize</title> </head> <body> <h1>WebSocket Authorize</h1> <button onclick=\"websocketfun()\">Send</button> <ul id='messages'> </ul> <script> const getCookie = (name) => { const value = `; $ {document.cookie} `; const parts = value.split(`; $ {name} =`); if (parts.length === 2) return parts.pop().split(';').shift(); } const websocketfun = () => { let csrf_token = getCookie(\"csrf_access_token\") let ws = new WebSocket(`ws://192.168.18.202:8000/ws?csrf_token=$ {csrf_token} `) ws.onmessage = (event) => { let messages = document.getElementById('messages') let message = document.createElement('li') let content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) } } </script> </body> </html> \"\"\" @app . get ( \"/\" ) async def get (): return HTMLResponse ( html ) @app . websocket ( '/ws' ) async def websocket ( websocket : WebSocket , csrf_token : str = Query ( ... ), Authorize : AuthJWT = Depends ()): await websocket . accept () try : Authorize . jwt_required ( \"websocket\" , websocket = websocket , csrf_token = csrf_token ) # Authorize.jwt_optional(\"websocket\",websocket=websocket,csrf_token=csrf_token) # Authorize.jwt_refresh_token_required(\"websocket\",websocket=websocket,csrf_token=csrf_token) # Authorize.fresh_jwt_required(\"websocket\",websocket=websocket,csrf_token=csrf_token) await websocket . send_text ( \"Successfully Login!\" ) decoded_token = Authorize . get_raw_jwt () await websocket . send_text ( f \"Here your decoded token: { decoded_token } \" ) except AuthJWTException as err : await websocket . send_text ( err . message ) await websocket . close () @app . get ( '/get-cookie' ) def get_cookie ( Authorize : AuthJWT = Depends ()): access_token = Authorize . create_access_token ( subject = 'test' , fresh = True ) refresh_token = Authorize . create_refresh_token ( subject = 'test' ) Authorize . set_access_cookies ( access_token ) Authorize . set_refresh_cookies ( refresh_token ) return { \"msg\" : \"Successfully login\" } You will see a simple page like this: You can get the token from URL /get-cookie : And click button send then your WebSocket route will respond back if the cookie and csrf token is match or cookie is valid or not:","title":"WebSocket Protecting"},{"location":"configuration/cookies/","text":"These are only applicable if authjwt_token_location is use cookies. authjwt_access_cookie_key The key of the cookie that holds the access token. Defaults to access_token_cookie authjwt_refresh_cookie_key The key of the cookie that holds the refresh token. Defaults to refresh_token_cookie authjwt_access_cookie_path What path should be set for the access cookie. Defaults to '/' , which will cause this access cookie to be sent in every request. authjwt_refresh_cookie_path What path should be set for the refresh cookie. Defaults to '/' , which will cause this refresh cookie to be sent in every request. authjwt_cookie_max_age If you don't set anything else, the cookie will expire when the browser is closed. Defaults to None , to prevent this set expiration to int (expressed in a number of seconds). authjwt_cookie_domain The domain can be used to specify a domain and subdomain for your cookies. Defaults to None which sets this cookie to only be readable by the domain that set it. authjwt_cookie_secure If the secure flag is True cookie can only be transmitted securely over HTTPS, and it will not be sent over unencrypted HTTP connections. Defaults to False , but in production this should likely be set to True authjwt_cookie_samesite The browser sends the cookie with both cross-site and same-site requests. Set to 'lax' in production to improve protection for CSRF attacks. Defaults to None , which means cookies are always sent through external or internal site.","title":"Cookies Options"},{"location":"configuration/csrf/","text":"authjwt_cookie_csrf_protect Enable/disable CSRF protection when using cookies. Defaults to True authjwt_access_csrf_cookie_key Key of the CSRF access cookie. Defaults to 'csrf_access_token' authjwt_refresh_csrf_cookie_key Key of the CSRF refresh cookie. Defaults to 'csrf_refresh_token' authjwt_access_csrf_cookie_path Path for the CSRF access cookie. Defaults to '/' authjwt_refresh_csrf_cookie_path Path for the CSRF refresh cookie. Defaults to '/' authjwt_access_csrf_header_name Name of the header that should contain the CSRF double submit value for access tokens. Defaults to X-CSRF-TOKEN authjwt_refresh_csrf_header_name Name of the header that should contains the CSRF double submit value for refresh tokens. Defaults to X-CSRF-TOKEN authjwt_csrf_methods The request methods that will use CSRF protection. Defaults to {'POST','PUT','PATCH','DELETE'}","title":"CSRF Options"},{"location":"configuration/denylist/","text":"authjwt_denylist_enabled Enable/disable token revoking. Defaults to False authjwt_denylist_token_checks What token types to check against the denylist. The options are access or refresh . You can pass in a sequence to check more than one type. Defaults to {'access', 'refresh'} . Only used if deny listing is enabled.","title":"Denylist Options"},{"location":"configuration/general/","text":"authjwt_token_location Where to look for a JWT when processing a request. The options are headers or cookies . You can pass in a sequence to set more than one location ('headers','cookies') . Defaults to {'headers'} if you pass headers and cookies, headers are precedence. authjwt_secret_key The secret key needed for symmetric based signing algorithms, such as HS* . Defaults to None authjwt_public_key The public key needed for asymmetric based signing algorithms, such as RS* or EC* . PEM format expected. Defaults to None authjwt_private_key The private key needed for asymmetric based signing algorithms, such as RS* or EC* . PEM format expected. Defaults to None authjwt_algorithm Which algorithm to sign the JWT with. See here for the options. Defaults to HS256 authjwt_decode_algorithms Which algorithms are allowed to decode a JWT. Defaults to a list with only the algorithm set in authjwt_algorithm authjwt_decode_leeway Define the leeway part of the expiration time definition, which means you can validate an expiration time which is in the past but not very far. Defaults to 0 authjwt_encode_issuer Define the issuer to set the issuer in JWT claims, only access token have issuer claim. Defaults to None authjwt_decode_issuer Define the issuer to check the issuer in JWT claims, only access token have issuer claim. Defaults to None authjwt_decode_audience The audience or list of audiences you expect in a JWT when decoding it. Defaults to None authjwt_access_token_expires How long an access token should live before it expires. This takes value integer (seconds) or datetime.timedelta , and defaults to 15 minutes . Can be set to False to disable expiration. authjwt_refresh_token_expires How long an refresh token should live before it expires. This takes value integer (seconds) or datetime.timedelta , and defaults to 30 days . Can be set to False to disable expiration.","title":"General Options"},{"location":"configuration/headers/","text":"These are only applicable if authjwt_token_location is use headers. authjwt_header_name What header to look for the JWT in a request. Defaults to Authorization authjwt_header_type What type of header the JWT is in. Defaults to Bearer . This can be an empty string, in which case the header contains only the JWT instead like HeaderName: Bearer <JWT>","title":"Headers Options"},{"location":"usage/basic/","text":"Create a file basic.py : from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str # in production you can use Settings management # from pydantic to get secret key from .env class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" # callback to get your configuration @AuthJWT . load_config def get_config (): return Settings () # exception handler for authjwt # in production, you can tweak performance using orjson response @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) # provide a method to create access tokens. The create_access_token() # function is used to actually generate the token to use authorization # later in endpoint protected @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # subject identifier for who this token is for example id or username from database access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } # protect endpoint with function jwt_required(), which requires # a valid access token in the request headers to access. @app . get ( '/user' ) def user ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user } Run the server with: $ uvicorn basic:app --host 0 .0.0.0 INFO: Started server process [ 9859 ] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://0.0.0.0:8000 ( Press CTRL+C to quit ) To access a jwt_required protected url, all we have to do is send in the JWT with the request. By default, this is done with an authorization header that looks like: Authorization: Bearer <access_token> We can see this in action using curl : $ curl http://localhost:8000/user { \"detail\" : \"Missing Authorization Header\" } $ curl -H \"Content-Type: application/json\" -X POST \\ -d '{\"username\":\"test\",\"password\":\"test\"}' http://localhost:8000/login { \"access_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0IiwiaWF0IjoxNjAzNjkyMjYxLCJuYmYiOjE2MDM2OTIyNjEsImp0aSI6IjZiMjZkZTkwLThhMDYtNDEzMy04MzZiLWI5ODJkZmI3ZjNmZSIsImV4cCI6MTYwMzY5MzE2MSwidHlwZSI6ImFjY2VzcyIsImZyZXNoIjpmYWxzZX0.ro5JMHEVuGOq2YsENkZigSpqMf5cmmgPP8odZfxrzJA\" } $ export TOKEN = eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0IiwiaWF0IjoxNjAzNjkyMjYxLCJuYmYiOjE2MDM2OTIyNjEsImp0aSI6IjZiMjZkZTkwLThhMDYtNDEzMy04MzZiLWI5ODJkZmI3ZjNmZSIsImV4cCI6MTYwMzY5MzE2MSwidHlwZSI6ImFjY2VzcyIsImZyZXNoIjpmYWxzZX0.ro5JMHEVuGOq2YsENkZigSpqMf5cmmgPP8odZfxrzJA $ curl -H \"Authorization: Bearer $TOKEN \" http://localhost:8000/user { \"user\" : \"test\" }","title":"Basic Usage"},{"location":"usage/freshness/","text":"The fresh tokens pattern is built into this extension. This pattern is very simple, you can choose to mark some access tokens as fresh and other as a non-fresh tokens, and use the fresh_jwt_required() function to only allow fresh tokens to access the certain endpoint. This is useful for allowing the fresh tokens to do some critical things (such as update information user) in real case you can see in the GitHub system when user wants to delete a repository in a certain time you need login if tokens not fresh again. Utilizing Fresh tokens in conjunction with refresh tokens can lead to a more secure site, without creating a bad user experience by making users constantly re-authenticate. Here is an example of how you could utilize refresh tokens with the fresh token pattern: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) # Standard login endpoint. Will return a fresh access token and a refresh token @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) \"\"\" create_access_token supports an optional 'fresh' argument, which marks the token as fresh or non-fresh accordingly. As we just verified their username and password, we are going to mark the token as fresh here. \"\"\" access_token = Authorize . create_access_token ( subject = user . username , fresh = True ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): \"\"\" Refresh token endpoint. This will generate a new access token from the refresh token, but will mark that access token as non-fresh, as we do not actually verify a password in this endpoint. \"\"\" Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user , fresh = False ) return { \"access_token\" : new_access_token } @app . post ( '/fresh-login' ) def fresh_login ( user : User , Authorize : AuthJWT = Depends ()): \"\"\" Fresh login endpoint. This is designed to be used if we need to make a fresh token for a user (by verifying they have the correct username and password). Unlike the standard login endpoint, this will only return a new access token, so that we don't keep generating new refresh tokens, which entirely defeats their point. \"\"\" if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) new_access_token = Authorize . create_access_token ( subject = user . username , fresh = True ) return { \"access_token\" : new_access_token } # Any valid JWT access token can access this endpoint @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user } # Only fresh JWT access token can access this endpoint @app . get ( '/protected-fresh' ) def protected_fresh ( Authorize : AuthJWT = Depends ()): Authorize . fresh_jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user }","title":"Freshness Tokens"},{"location":"usage/jwt-in-cookies/","text":"Highly recommended using JWT in cookies, if your frontend interacts with the backend, your frontend may be storing JWT in the browser localStorage or sessionStorage. There is nothing wrong with this, but if you have any sort of XSS vulnerability on your site, an attacker will be able to trivially steal your tokens. If you want some additional security on your site, you can save your JWT in an httponly cookies. Which keeps javascript cannot be able to access the cookies. Here is a basic example of how to store JWT in cookies: Note You can also create cookies or unset cookies when returning a Response directly in your code. To do that, you can create a response then set the response in set cookies or unset cookies ... response = JSONResponse ( content = { \"msg\" : \"Successfully login\" }) # Set the JWT and CSRF double submit cookies in the response Authorize . set_access_cookies ( access_token , response ) Authorize . set_refresh_cookies ( refresh_token , response ) return response from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel \"\"\" Note: This is just a basic example how to enable cookies. This is vulnerable to CSRF attacks, and should not be used this example. \"\"\" app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" # Configure application to store and get JWT from cookies authjwt_token_location : set = { \"cookies\" } # Disable CSRF Protection for this example. default is True authjwt_cookie_csrf_protect : bool = False @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # Create the tokens and passing to set_access_cookies or set_refresh_cookies access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) # Set the JWT cookies in the response Authorize . set_access_cookies ( access_token ) Authorize . set_refresh_cookies ( refresh_token ) return { \"msg\" : \"Successfully login\" } @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) # Set the JWT cookies in the response Authorize . set_access_cookies ( new_access_token ) return { \"msg\" : \"The token has been refresh\" } @app . delete ( '/logout' ) def logout ( Authorize : AuthJWT = Depends ()): \"\"\" Because the JWT are stored in an httponly cookie now, we cannot log the user out by simply deleting the cookies in the frontend. We need the backend to send us a response to delete the cookies. \"\"\" Authorize . jwt_required () Authorize . unset_jwt_cookies () return { \"msg\" : \"Successfully logout\" } @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): \"\"\" We do not need to make any changes to our protected endpoints. They will all still function the exact same as they do when sending the JWT in via a headers instead of a cookies \"\"\" Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user } This isn't the full story. However now we can keep our cookies from being stolen via XSS attacks, but session cookies vulnerable to CSRF attacks. To combat CSRF attacks we are going to use a technique called double submit cookie pattern. Double submitting cookies is defined as sending a random value in both a cookie and as a request parameter, with the server verifying if the cookie value and request value are equal. Double Submit Cookie Pattern This tokens is saved in a cookie with httponly set to True, so it cannot be accessed via javascript. We will then create a secondary cookie that contains an only random string, but has httponly set to False so that it can be accessed via javascript running on your website. Now in order to access a protected endpoint, you will need to add a custom header that contains the random string in it, and if that header doesn\u2019t exist or it doesn\u2019t match the string that is stored in the JWT, the requester will be kicked out as unauthorized. To break this down, if an attacker attempts to perform a CSRF attack they will send the JWT (via cookie) to protected endpoint, but without the random string in the request headers, they won't be able to access the endpoint. They cannot access the random string unless they can run javascript on your website likely via an XSS attack , and if they are able to perform an XSS attack, they will not be able to steal the actual access and refresh JWT, as javascript is still not able to access those httponly cookies. No system is safe. If an attacker can perform an XSS attack they can still access protected endpoints from people who visit your site. However, it is better than if they were able to steal the access and refresh tokens from local/session storage, and use them whenever they wanted. Here is an example of using cookies with CSRF protection: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel \"\"\" By default, the CRSF cookies will be called csrf_access_token and csrf_refresh_token, and in protected endpoints we will look for the CSRF token in the 'X-CSRF-Token' headers. only certain methods should define CSRF token in headers default is ('POST','PUT','PATCH','DELETE') \"\"\" app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" # Configure application to store and get JWT from cookies authjwt_token_location : set = { \"cookies\" } # Only allow JWT cookies to be sent over https authjwt_cookie_secure : bool = False # Enable csrf double submit protection. default is True authjwt_cookie_csrf_protect : bool = True # Change to 'lax' in production to make your website more secure from CSRF Attacks, default is None # authjwt_cookie_samesite: str = 'lax' @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): \"\"\" With authjwt_cookie_csrf_protect set to True, set_access_cookies() and set_refresh_cookies() will now also set the non-httponly CSRF cookies \"\"\" if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # Create the tokens and passing to set_access_cookies or set_refresh_cookies access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) # Set the JWT and CSRF double submit cookies in the response Authorize . set_access_cookies ( access_token ) Authorize . set_refresh_cookies ( refresh_token ) return { \"msg\" : \"Successfully login\" } @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) # Set the JWT and CSRF double submit cookies in the response Authorize . set_access_cookies ( new_access_token ) return { \"msg\" : \"The token has been refresh\" } @app . delete ( '/logout' ) def logout ( Authorize : AuthJWT = Depends ()): \"\"\" Because the JWT are stored in an httponly cookie now, we cannot log the user out by simply deleting the cookie in the frontend. We need the backend to send us a response to delete the cookies. \"\"\" Authorize . jwt_required () Authorize . unset_jwt_cookies () return { \"msg\" : \"Successfully logout\" } @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user }","title":"JWT in Cookies"},{"location":"usage/optional/","text":"In some cases you want to use one endpoint for both, protected and unprotected. In this situation you can use function jwt_optional() . This will allow the endpoint to be accessed regardless of if a JWT is sent in the request or not. If a JWT get tampering or expired an error will be returned instead of calling the endpoint. from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } @app . get ( '/partially-protected' ) def partially_protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_optional () # If no jwt is sent in the request, get_jwt_subject() will return None current_user = Authorize . get_jwt_subject () or \"anonymous\" return { \"user\" : current_user }","title":"Partially Protecting"},{"location":"usage/refresh/","text":"These are long-lived tokens which can be used to create a new access tokens once an old access token has expired. Refresh tokens cannot access an endpoint that is protected with jwt_required() , jwt_optional() , and fresh_jwt_required() and access tokens cannot access an endpoint that is protected with jwt_refresh_token_required() . Utilizing refresh tokens we can help reduce the damage that can be done if an access tokens is stolen. However, if an attacker gets a refresh tokens they can keep generating new access tokens and accessing protected endpoints as though he was that user. We can help combat this by using the fresh tokens pattern, discussed in the next section. Note For accessing /refresh endpoint remember to change access_token with refresh_token in the header Authorization: Bearer <refresh_token> Here is an example of using access and refresh tokens: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # Use create_access_token() and create_refresh_token() to create our # access and refresh tokens access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): \"\"\" The jwt_refresh_token_required() function insures a valid refresh token is present in the request before running any code below that function. we can use the get_jwt_subject() function to get the subject of the refresh token, and use the create_access_token() function again to make a new access token \"\"\" Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user }","title":"Refresh Tokens"},{"location":"usage/revoking/","text":"This will allow you to revoke a specific tokens so that it can no longer access your endpoints. You will have to choose what tokens you want to check against the denylist. Denylist works by providing a callback function to this extension, using the token_in_denylist_loader() . This method will be called whenever the specified tokens (access and/or refresh) is used to access a protected endpoint. If the callback function says that the tokens is revoked, we will not allow the requester to continue, otherwise we will allow the requester to access the endpoint as normal. Here is a basic example use tokens revoking: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str # set denylist enabled to True # you can set to check access or refresh token or even both of them class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" authjwt_denylist_enabled : bool = True authjwt_denylist_token_checks : set = { \"access\" , \"refresh\" } @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) # A storage engine to save revoked tokens. in production, # you can use Redis for storage system denylist = set () # For this example, we are just checking if the tokens jti # (unique identifier) is in the denylist set. This could # be made more complex, for example storing the token in Redis # with the value true if revoked and false if not revoked @AuthJWT . token_in_denylist_loader def check_if_token_in_denylist ( decrypted_token ): jti = decrypted_token [ 'jti' ] return jti in denylist @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } # Standard refresh endpoint. Token in denylist will not # be able to access this endpoint @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } # Endpoint for revoking the current users access token @app . delete ( '/access-revoke' ) def access_revoke ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () jti = Authorize . get_raw_jwt ()[ 'jti' ] denylist . add ( jti ) return { \"detail\" : \"Access token has been revoke\" } # Endpoint for revoking the current users refresh token @app . delete ( '/refresh-revoke' ) def refresh_revoke ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () jti = Authorize . get_raw_jwt ()[ 'jti' ] denylist . add ( jti ) return { \"detail\" : \"Refresh token has been revoke\" } # A token in denylist will not be able to access this any more @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user } In production, you will likely want to use either a database or in-memory store (such as Redis) to store your tokens. Memory stores are great if you are wanting to revoke a tokens when the users log out and you can define timeout to your tokens in Redis, after the timeout has expired, the tokens will automatically be deleted. Note Before that make sure redis already installed on your local machine, you can use docker using this command docker run -d -p 6379:6379 redis Here example use Redis for revoking a tokens: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel from datetime import timedelta from redis import Redis app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" authjwt_denylist_enabled : bool = True authjwt_denylist_token_checks : set = { \"access\" , \"refresh\" } access_expires : int = timedelta ( minutes = 15 ) refresh_expires : int = timedelta ( days = 30 ) settings = Settings () @AuthJWT . load_config def get_config (): return settings @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) # Setup our redis connection for storing the denylist tokens redis_conn = Redis ( host = 'localhost' , port = 6379 , db = 0 , decode_responses = True ) # Create our function to check if a token has been revoked. In this simple # case, we will just store the tokens jti (unique identifier) in redis. # This function will return the revoked status of a token. If a token exists # in redis and value is true, token has been revoked @AuthJWT . token_in_denylist_loader def check_if_token_in_denylist ( decrypted_token ): jti = decrypted_token [ 'jti' ] entry = redis_conn . get ( jti ) return entry and entry == 'true' @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" or user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } # Standard refresh endpoint. Token in denylist will not # be able to access this endpoint @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } # Endpoint for revoking the current users access token @app . delete ( '/access-revoke' ) def access_revoke ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () # Store the tokens in redis with the value true for revoked. # We can also set an expires time on these tokens in redis, # so they will get automatically removed after they expired. jti = Authorize . get_raw_jwt ()[ 'jti' ] redis_conn . setex ( jti , settings . access_expires , 'true' ) return { \"detail\" : \"Access token has been revoke\" } # Endpoint for revoking the current users refresh token @app . delete ( '/refresh-revoke' ) def refresh_revoke ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () jti = Authorize . get_raw_jwt ()[ 'jti' ] redis_conn . setex ( jti , settings . refresh_expires , 'true' ) return { \"detail\" : \"Refresh token has been revoke\" } # A token in denylist will not be able to access this any more @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user }","title":"Revoking Tokens"}]}